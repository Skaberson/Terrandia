<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Terrandia</title>
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/Skaberson/test123/main/images/icon2.png">
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      background: #222;
      width: 100vw;
      height: 100vh;
      font-family: 'Courier New', monospace;
    }
    
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    #game {
      display: block;
      background: #223366;
      width: 120%;
      height: 120%;
    }
    
    #fullscreenButton {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      padding: 8px 12px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: 1px solid #fffd7f;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    
    #fullscreenButton:hover {
      background: rgba(0,0,0,0.9);
    }
    
    /* Terraria-style inventory panel */
    #inventoryPanel {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%);
      background: rgba(30, 30, 40, 0.95); 
      color: #fff; 
      font-family: 'Courier New', monospace;
      border: 3px solid #8B4513;
      border-radius: 8px; 
      width: 320px;
      height: 400px;
      z-index: 10; 
      display: none;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      padding: 10px;
      box-sizing: border-box;
    }
    
    #inventoryPanel h2 { 
      margin: 0 0 10px 0; 
      font-size: 18px; 
      text-align: center;
      color: #FFD700;
      text-shadow: 0 0 4px #000;
      border-bottom: 2px solid #8B4513;
      padding-bottom: 5px;
    }
    
    #inventorySlots {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 4px;
      height: 200px;
      padding: 5px;
    }
    
    .inventory-slot {
      background: #222;
      border: 2px solid #555;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .inventory-slot:hover {
      border-color: #FFD700;
      background: #333;
    }
    
    .inventory-slot.selected {
      border-color: #FFD700;
      background: #444;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
    }
    
    .slot-item {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      border: 1px solid #888;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 2px;
    }
    
    .slot-count {
      font-size: 10px;
      color: #FFD700;
      text-shadow: 0 0 2px #000;
    }
    
    .slot-key {
      position: absolute;
      top: 1px;
      right: 2px;
      font-size: 8px;
      color: #FFD700;
      opacity: 0.8;
    }
    
    /* Terraria-style crafting panel */
    #craftingPanel {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%);
      background: rgba(30, 30, 40, 0.95); 
      color: #fff; 
      font-family: 'Courier New', monospace;
      border: 3px solid #8B4513;
      border-radius: 8px; 
      width: 400px;
      height: 450px;
      z-index: 15; 
      display: none;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      padding: 10px;
      box-sizing: border-box;
    }
    
    #craftingPanel h2 { 
      margin: 0 0 10px 0; 
      font-size: 18px; 
      text-align: center;
      color: #FFD700;
      text-shadow: 0 0 4px #000;
      border-bottom: 2px solid #8B4513;
      padding-bottom: 5px;
    }
    
    #craftingRecipes {
      display: flex;
      flex-direction: column;
      gap: 10px;
      height: 380px;
      overflow-y: auto;
      padding: 5px;
    }
    
    .recipe-item {
      background: rgba(40, 40, 50, 0.7);
      border: 2px solid #555;
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .recipe-item:hover {
      border-color: #FFD700;
      background: rgba(50, 50, 60, 0.9);
    }
    
    .recipe-icon {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      border: 1px solid #888;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      background: #333;
    }
    
    .recipe-details {
      flex: 1;
    }
    
    .recipe-name {
      font-weight: bold;
      color: #FFD700;
      margin-bottom: 3px;
    }
    
    .recipe-ingredients {
      font-size: 12px;
      color: #aaa;
    }
    
    .recipe-result {
      font-size: 12px;
      color: #FFD700;
      font-weight: bold;
    }
    
    #craftingPanel .close-btn {
      position: absolute; 
      top: 10px; 
      right: 10px; 
      background: none; 
      border: none; 
      color: #fff; 
      cursor: pointer;
      font-size: 16px; 
      width: 24px; 
      height: 24px; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      border-radius: 3px;
      transition: background 0.2s;
    }
    
    #craftingPanel .close-btn:hover {
      background: rgba(255, 0, 0, 0.3);
    }
    
    /* Admin panel */
    #adminPanel {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 20, 0.95); 
      color: #fff; 
      font-family: 'Courier New', monospace;
      border: 3px solid #7fffd4;
      border-radius: 8px; 
      width: 350px;
      height: 400px;
      z-index: 30; 
      display: none;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      padding: 15px;
      box-sizing: border-box;
    }
    
    #adminPanel h3 { 
      margin: 0 0 15px 0; 
      font-size: 18px; 
      text-align: center; 
      color: #bfffdc;
      text-shadow: 0 0 4px #000;
    }
    
    #adminPanel .row { 
      display:flex; 
      gap:10px; 
      align-items:center; 
      margin:8px 0; 
    }
    
    #adminPanel label { 
      flex:1; 
      font-size:14px; 
      opacity:0.9; 
    }
    
    #adminPanel input[type="text"], #adminPanel input[type="password"] {
      background:#141416; 
      color:#fff; 
      border:2px solid #555; 
      padding:6px 8px; 
      border-radius:4px; 
      min-width:130px;
      font-family: 'Courier New', monospace;
    }
    
    #adminPanel button {
      background: linear-gradient(#1b5,#0a6); 
      border:2px solid #083; 
      color:#012; 
      padding:6px 8px; 
      border-radius:4px; 
      cursor:pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    #adminPanel .danger {
      background: linear-gradient(#f66,#d33); 
      border:2px solid #b11; 
      color:#fff;
    }
    
    #adminPanel .checkbox { 
      transform: translateY(2px); 
    }
    
    #adminMessage { 
      font-size:13px; 
      color:#dff; 
      opacity:0.95; 
      text-align:center; 
      margin-top:8px; 
      padding: 5px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }
    
    #adminLogin { 
      display:block; 
    }
    
    #adminControls { 
      display:none; 
    }
    
    /* Character customization panel */
    #characterPanel {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%);
      background: rgba(30, 30, 40, 0.95); 
      color: #fff; 
      font-family: 'Courier New', monospace;
      border: 3px solid #8B4513;
      border-radius: 8px; 
      width: 400px;
      height: 350px;
      z-index: 20; 
      display: none;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      padding: 15px;
      box-sizing: border-box;
    }
    
    #characterPanel h2 { 
      margin: 0 0 15px 0; 
      font-size: 18px; 
      text-align: center;
      color: #FFD700;
      text-shadow: 0 0 4px #000;
      border-bottom: 2px solid #8B4513;
      padding-bottom: 5px;
    }
    
    #characterPreview {
      width: 100px;
      height: 100px;
      margin: 0 auto 15px;
      background: #222;
      border: 2px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    #characterPreview img {
      max-width: 100%;
      max-height: 100%;
    }
    
    #characterUrlInput {
      width: 100%;
      padding: 8px;
      margin-bottom: 15px;
      background: #141416;
      color: #fff;
      border: 2px solid #555;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }
    
    #characterPanel .close-btn {
      position: absolute; 
      top: 10px; 
      right: 10px; 
      background: none; 
      border: none; 
      color: #fff; 
      cursor: pointer;
      font-size: 16px; 
      width: 24px; 
      height: 24px; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      border-radius: 3px;
      transition: background 0.2s;
    }
    
    #characterPanel .close-btn:hover {
      background: rgba(255, 0, 0, 0.3);
    }
    
    /* Hotbar */
    #hotbar {
      position: absolute; 
      bottom: 20px; 
      left: 50%; 
      transform: translateX(-50%);
      display: flex; 
      gap: 4px; 
      z-index: 5; 
      pointer-events: none;
    }
    
    .hotbar-slot {
      width: 100px; 
      height: 100px; 
      border-radius: 6px; 
      border: 2px solid #888;
      background: #222c; 
      box-sizing: border-box; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center;
      font-family: 'Courier New', monospace; 
      font-size: 14px; 
      font-weight: bold; 
      color: #fff; 
      position: relative; 
      transition: border 0.1s, background 0.1s;
      user-select: none;
      cursor: pointer;
    }
    
    .hotbar-slot.selected { 
      border: 2.8px solid #FFD700; 
      background: #242d; 
      pointer-events: auto; 
    }
    
    .hotbar-slot .slot-key {
      position: absolute; 
      top: 4px; 
      right: 5px; 
      font-size: 4px; 
      color: #FFD700; 
      opacity: 0.8;
    }
    
    .hotbar-slot .slot-count {
      position: absolute; 
      bottom: 2px; 
      right: 4px; 
      font-size: 40px; 
      color: #FFD700;
      text-shadow: 0 0 2px #000;
      font-weight: normal;
    }
    
    .hotbar-slot .slot-swatch {
      width: 20px; 
      height: 20px; 
      border-radius: 3px; 
      margin-top: 8px;
      border: 1.2px solid #888;
      margin-bottom: 3px;
      box-sizing: border-box;
    }
    
    /* Small helper notes */
    .hint { 
      font-size:12px; 
      opacity:0.7; 
      margin-top:6px; 
      text-align:center; 
    }
    
    /* Scrollbar styling */
    #craftingRecipes::-webkit-scrollbar {
      width: 8px;
    }
    
    #craftingRecipes::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.2);
    }
    
    #craftingRecipes::-webkit-scrollbar-thumb {
      background: #8B4513;
      border-radius: 4px;
    }
    
    #craftingRecipes::-webkit-scrollbar-thumb:hover {
      background: #FFD700;
    }
  </style>
</head>
<body>
  <!-- Add health bar display -->
<div id="healthBarContainer" style="position: absolute; top: 20px; left: 20px; width: 200px; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid #888; border-radius: 4px; z-index: 100;">
  <div id="healthBar" style="height: 100%; width: 100%; background: linear-gradient(to right, #ff0000, #ff6600); border-radius: 2px; transition: width 0.3s;"></div>
  <div id="healthText" style="position: absolute; top: 0; left: 0; width: 100%; text-align: center; color: white; font-family: 'Courier New', monospace; font-size: 12px; text-shadow: 1px 1px 1px black;">100%</div>
</div>

<!-- Add fall damage indicator -->
<div id="fallDamageIndicator" style="position: absolute; top: 50px; left: 20px; color: #ff5555; font-family: 'Courier New', monospace; font-size: 14px; opacity: 0; transition: opacity 0.3s; z-index: 100;">
  Fall Damage: 0
</div>

  <div id="gameContainer">
    <canvas id="game" tabindex="0"></canvas>
    <button id="fullscreenButton">Toggle Fullscreen</button>
    
    <!-- Inventory Panel -->
    <div id="inventoryPanel">
      <h2>Inventory</h2>
      <div id="inventorySlots"></div>
    </div>

    <!-- Crafting Panel -->
    <div id="craftingPanel">
      <button class="close-btn" id="closeCrafting">✕</button>
      <h2>Crafting</h2>
      <div id="craftingRecipes"></div>
    </div>

    <!-- Character Customization Panel -->
    <div id="characterPanel">
      <button class="close-btn" id="closeCharacter">✕</button>
      <h2>Character Customization</h2>
      <div id="characterPreview">
        <img id="characterPreviewImg" src="" alt="Character Preview">
      </div>
      <div class="hint">Select a character preset</div>
      <div id="characterPresets">
        <button class="preset-btn" data-preset="default">Default</button>
        <button class="preset-btn" data-preset="warrior">Warrior</button>
        <button class="preset-btn" data-preset="mage">Mage</button>
        <button class="preset-btn" data-preset="archer">Archer</button>
      </div>
    </div>

    <!-- Admin panel -->
    <div id="adminPanel" aria-hidden="true">
      <h3>Admin Console</h3>

      <div id="adminLogin">
        <div class="row">
          <label>Password:</label>
          <input id="adminPassword" type="password" placeholder="enter password" />
          <button id="adminLoginBtn">Login</button>
        </div>
        <div class="hint">Press P to open this panel. Password required.</div>
        <div id="adminLoginMsg" class="hint" style="color:#f88"></div>
      </div>

      <div id="adminControls">
        <div class="row">
          <label>Enable Dynamine (instant 3x3 mining)</label>
          <input id="dynamineToggle" class="checkbox" type="checkbox" />
        </div>
        <div class="row">
          <label>Enable Noclip (walk through blocks)</label>
          <input id="noclipToggle" class="checkbox" type="checkbox" />
        </div>
        <div class="row">
          <label>Enable Fly (disable gravity; use W/S to move up/down)</label>
          <input id="flyToggle" class="checkbox" type="checkbox" />
        </div>
        <div class="row">
          <label>Give 99 of selected hotbar item</label>
          <button id="give99Btn">Give 99</button>
        </div>
        <div class="row">
          <label>Teleport to spawn (0, surface)</label>
          <button id="teleportBtn">Teleport</button>
        </div>
        <div class="row">
          <label>Clear nearby blocks 5x5 (centered)</label>
          <button id="clear5Btn">Clear 5x5</button>
        </div>
        
        <!-- Add these lines to the admin panel HTML section in index.html, 
     right before the closeAdminBtn and logoutAdminBtn: -->
<div class="row">
  <label>Teleport to Biome</label>
  <button id="teleportBiomesBtn">Teleport</button>
</div>
<div class="row">
  <label>Teleport to Sky Island</label>
  <button id="teleportSkyBtn">Teleport</button>
</div>


        <div style="display:flex; gap:10px; justify-content:center; margin-top:10px;">
          <button id="closeAdminBtn">Close</button>
          <button id="logoutAdminBtn" class="danger">Logout</button>
        </div>

        <div id="adminMessage"></div>
      </div>
    </div>

    <div id="hotbar"></div>
  </div>
  
  <script>
    // --- Config ---
    const BLOCK_SIZE = 87;
    const BLOCK_SCALE = 1.01;
    const BACKGROUND_BLOCK_SCALE = 2.0;
    const CAMERA_WIDTH = 16;
    const CAMERA_HEIGHT = 9;
    const GROUND_LEVEL = 10;
    const GRAVITY = 0.4;
    const JUMP_VEL = 7;
    const MOVE_SPEED = 3.2;
    const TICK = 1/60;
    const CHUNK_SIZE = 32;
    const MINE_REACH = 5;
    let RENDER_SCALE = 1;

    // Admin password (as requested)
    const ADMIN_PASSWORD = "ultragaming";

    // --- Underworld layers config ---
    const UNDERWORLD_LAYERS = [
      { name: "styx_temple", y: -150, height: 10, bg: "styx_bg" },
      { name: "elysium", y: -250, height: 10, bg: "elysium_bg" },
      { name: "asphodel", y: -350, height: 10, bg: "asphodel_bg" },
      { name: "tartarus", y: -450, height: 14, bg: "tartarus_bg" },
      { name: "hades_house", y: -500, height: 20, bg: "hades_bg" }
    ];

    // --- Block toughness for mining speed (seconds to mine) ---
    const TOUGHNESS = {
      air: 0,
      grass: 0.6,
      dirt: 0.7,
      stone: 1.2,
      sand: 0.5,
      clay: 0.8,
      snow: 0.5,
      hotstone: 1.5,
      magma: 1.8,
      lava: 0,
      leaf: 0.3,
      wood: 0.9,
      brick: 1.4,
      ore: 2.0,
      player: 0,
      select: 0,
      cloud: 0.4,
      hellstone: 2.5,
      styx_temple: 2.2,
      elysium: 1.6,
      asphodel: 1.8,
      tartarus: 2.8,
      hades_house: 3.0,
      darkstone_bg: 0, // unminable
      styx_bg: 0,
      elysium_bg: 0,
      asphodel_bg: 0,
      tartarus_bg: 0,
      hades_bg: 0
    };

    // --- Block colors (fallback) ---
    const COLORS = {
      air: "#223366",
      grass: "#3cbb3c",
      dirt: "#87692b",
      stone: "#888",
      sand: "#e8e2aa",
      clay: "#b97a56",
      snow: "#e0e8f0",
      hotstone: "#c75d35",
      magma: "#f85a0a",
      lava: "#ff4100",
      leaf: "#5ed04b",
      wood: "#7c4f20",
      brick: "#a64832",
      ore: "#e4e45c",
      player: "#fff1c1",
      select: "#fffd7f",
      cloud: "#e3eaff",
      hellstone: "#6c162b",
      styx_temple: "#d4bfae",
      elysium: "#a1e2c1",
      asphodel: "#cfcfcf",
      tartarus: "#5c1a5c",
      hades_house: "#222222",
      darkstone_bg: "#333344",
      styx_bg: "#b2a17c",
      elysium_bg: "#8ec9aa",
      asphodel_bg: "#bbbbbb",
      tartarus_bg: "#3a083a",
      hades_bg: "#111111"
    };

    // --- Block images (edit these for custom textures!) ---
    const BLOCK_IMAGES = {
      grass: "https://raw.githubusercontent.com/Skaberson/test123/main/images/grass.png",
      dirt: "https://raw.githubusercontent.com/Skaberson/test123/main/images/dirt_00.png",
      stone: "https://raw.githubusercontent.com/Skaberson/test123/main/images/stone.png",
      sand: "https://raw.githubusercontent.com/Skaberson/test123/main/images/newsand.png",
      clay: "https://raw.githubusercontent.com/Skaberson/test123/main/images/clay.png",
      snow: "https://raw.githubusercontent.com/Skaberson/test123/main/images/newsnow.png",
      hotstone: "https://raw.githubusercontent.com/Skaberson/test123/main/images/hotstone.png",
      magma: "https://raw.githubusercontent.com/Skaberson/test123/main/images/magma.png",
      lava: "https://raw.githubusercontent.com/Skaberson/test123/main/images/magma.png",
      leaf: "https://raw.githubusercontent.com/Skaberson/test123/main/images/leaves_00.png",
      wood: "https://raw.githubusercontent.com/Skaberson/test123/main/images/wood_0.png",
      brick: "",
      ore: "https://raw.githubusercontent.com/Skaberson/test123/main/images/ironore.png",
      cloud: "https://raw.githubusercontent.com/Skaberson/test123/main/images/cloud.png",
      hellstone: "https://raw.githubusercontent.com/Skaberson/test123/main/images/hellstone.png",
      styx_temple: "",
      elysium: "",
      asphodel: "",
      tartarus: "",
      hades_house: "",
      darkstone_bg: "",
      styx_bg: "",
      elysium_bg: "",
      asphodel_bg: "",
      tartarus_bg: "",
      hades_bg: ""
    };

    // --- Hotbar blocks (no unminable backgrounds) ---
    const HOTBAR_BLOCKS = [
      "dirt", "stone", "sand", "clay", "snow", "hellstone", "magma", "wood", "brick", "cloud"
    ];

    // --- Crack texture image (set this to your texture's URL) ---
    const CRACK_IMAGE_URL = "https://raw.githubusercontent.com/Skaberson/Terrandia/main/images/crack.png";

    // --- Preload images and track status ---
    const imageCache = {};
    for (const [type, url] of Object.entries(BLOCK_IMAGES)) {
      if (url) {
        const img = new window.Image();
        img.src = url;
        imageCache[type] = {
          img,
          loaded: false,
          error: false
        };
        img.onload = () => { imageCache[type].loaded = true; };
        img.onerror = () => { imageCache[type].error = true; };
      }
    }
    // Preload crack image
    const crackImg = new window.Image();
    crackImg.src = CRACK_IMAGE_URL;
    let crackLoaded = false;
    crackImg.onload = () => { crackLoaded = true; };

    // --- PRNG and Noise ---
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function smoothstep(t) { return t * t * (3 - 2 * t); }
    function valueNoise(x, seed) {
      let rnd = mulberry32(seed + x*73856093);
      return rnd();
    }
    function perlin1d(x, seed) {
      let xi = Math.floor(x);
      let xf = x - xi;
      let l = valueNoise(xi, seed), r = valueNoise(xi+1, seed);
      return lerp(l, r, smoothstep(xf));
    }

    // --- Biomes ---
    function getBiome(x) {
      const bseed = 234567;
      const n = perlin1d(x / 64, bseed * 13);
      if (n < 0.25) {
        return { name: "desert", surface: "sand", dirt: "sand", stone: "stone", tree: null };
      } else if (n < 0.48) {
        return { name: "snow", surface: "snow", dirt: "snow", stone: "stone", tree: null };
      } else if (n < 0.75) {
        return { name: "forest", surface: "grass", dirt: "dirt", stone: "stone", tree: "oak" };
      } else {
        return { name: "clay", surface: "clay", dirt: "clay", stone: "stone", tree: null };
      }
    }

    // --- Infinite World Storage ---
    let world = {};
    let background = {};  // stores background blocks
    // Replace the hardcoded seed with a random one
    const seed = Math.floor(Math.random() * 1000000);
    function getBlock(x, y) {
      const key = x + "," + y;
      if(world.hasOwnProperty(key)) return world[key];
      return null;
    }
    function setBlock(x, y, type) {
      world[x+','+y] = type;
    }
    function getBackground(x, y) {
      const key = x + "," + y;
      if(background.hasOwnProperty(key)) return background[key];
      return null;
    }
    function setBackground(x, y, type) {
      background[x+','+y] = type;
    }

    // --- Greek Underworld Layer Generation ---
    function isUnderworldLayer(y) {
      for (const layer of UNDERWORLD_LAYERS) {
        if (y >= layer.y && y < layer.y + layer.height)
          return layer;
      }
      return null;
    }

    // --- Sky Islands Helper ---
    function generateSkyIsland(x, y) {
      let islandRadiusX = 4 + Math.floor(valueNoise(x*2, seed)*3);
      let islandRadiusY = 2 + Math.floor(valueNoise(x*3, seed)*2);
      let hasGrass = valueNoise(x*4, seed) > 0.5;
      for (let ix = -islandRadiusX; ix <= islandRadiusX; ix++) {
        for (let iy = -islandRadiusY; iy <= islandRadiusY; iy++) {
          if ((ix*ix)/(islandRadiusX*islandRadiusX) + (iy*iy)/(islandRadiusY*islandRadiusY) <= 1) {
            setBlock(x+ix, y+iy, "cloud");
            if (iy === -islandRadiusY && hasGrass && Math.abs(ix) <= islandRadiusX-1) {
              setBlock(x+ix, y+iy-1, valueNoise(x+ix, seed*7) > 0.5 ? "grass" : "dirt");
            }
          }
        }
      }
    }

    function cave2D(x, y, biome, surf) {
      if (y <= surf + 70) return false;
      let caveNoise = perlin1d(x/8 + y/16, 777+biome.name.length)*0.6
                    + perlin1d(x/18 - y/25, 888-biome.name.length)*0.4;
      let tunnelNoise = perlin1d(x/13 + y/45, 999)*0.7
                      + perlin1d(x/52 - y/55, 333)*0.3;
      let depth = y-surf-6;
      let caveProb = 0.71 + Math.min(0.18, depth/80);
      let tunnelProb = 0.85 + Math.min(0.12, depth/200);
      return (caveNoise > caveProb) || (tunnelNoise > tunnelProb);
    }

    function generateChunk(cx, cy) {
      for(let dx=0; dx<CHUNK_SIZE; dx++) {
        let x = cx * CHUNK_SIZE + dx;
        const biome = getBiome(x);
        let h = Math.floor(GROUND_LEVEL + perlin1d(x/8, seed)*7 + perlin1d(x/2, seed*2)*3 + perlin1d(x/18, seed*biome.name.length)*2);

        let skyY = h - 100;
        if (cy === Math.floor(skyY / CHUNK_SIZE)) {
          if (valueNoise(x, 99999) > 0.985) {
            let islandY = skyY + Math.floor(valueNoise(x*11, seed)*8) - 3;
            generateSkyIsland(x, islandY);
          }
        }

        for(let dy=0; dy<CHUNK_SIZE; dy++) {
          let y = cy * CHUNK_SIZE + dy;
          let key = x + "," + y;
          if(world.hasOwnProperty(key)) continue;

          // --- Greek Underworld Layers ---
          let layer = isUnderworldLayer(y);
          if (layer) {
            // Set background for the layer
            setBackground(x, y, layer.bg);
            
            // Set foreground block for the layer
            if (y === layer.y || y === layer.y + layer.height - 1) {
              // Top and bottom layers
              setBlock(x, y, layer.name);
            } else {
              // Middle layers - add some variation
              if (x % 10 === 0 || x % 10 === 9) {
                // Add some structure along the edges
                setBlock(x, y, layer.name);
              } else if (valueNoise(x + y, seed) > 0.95) {
                // Random blocks in the middle
                setBlock(x, y, layer.name);
              } else {
                // Otherwise leave air
                setBlock(x, y, "air");
              }
            }
            continue;
          }

          // --- Normal terrain generation ---
          let type = "air";
          let temp = 0.0 + y*0.008;
          let stoneType = "stone";
          if (temp > 2.5) stoneType = "hotstone";
          if (temp > 5.5) stoneType = "magma";
          if (temp > 8.5) stoneType = "lava";
          if (y > h + 200) {
            if (valueNoise(x + y*13, seed*3) > 0.92) {
              type = "lava";
            } else {
              type = "hellstone";
            }
          }
          else if(y < h) type = 'air';
          else if(y == h) type = biome.surface;
          else if(y < h+3) type = biome.dirt;
          else type = stoneType;
          if (y > h+1 && type !== 'air' && cave2D(x, y, biome, h)) type = 'air';
          if((type === "stone" || type === "hotstone" || type==="magma") && valueNoise(x + y*31, seed*4) > 0.995) type = "ore";
          if (y === h && valueNoise(Math.floor(x/8), 3333) < 0.025) {
            for (let sx = -2; sx <= 2; sx++) for (let sy = 0; sy < 4; sy++) {
              let wx = x + sx, wy = y - sy;
              if (sy === 0) setBlock(wx, wy, "brick");
              else if (sy === 3) setBlock(wx, wy, "leaf");
              else if (sx === -2 || sx === 2) setBlock(wx, wy, "wood");
              else setBlock(wx, wy, "air"); 
            }
            setBlock(x, y-1, "air");
          }
          if(biome.tree && y === h && valueNoise(x, 555) > 0.94) {
            setBlock(x, y-1, "wood"); setBlock(x, y-2, "wood");
            setBlock(x, y-3, "leaf");
            setBlock(x-1, y-3, "leaf"); setBlock(x+1, y-3, "leaf");
            setBlock(x, y-4, "leaf");
          }
          world[key] = type;

          // --- Background logic: 5 blocks below surface level, darker stone background
          if (y >= h + 5 && y < h + 10 && type !== 'air') {
            setBackground(x, y, "darkstone_bg");
          }
        }
      }
    }

    function ensureWorldGenerated(camX, camY) {
      let left = Math.floor(camX - CAMERA_WIDTH/2);
      let top = Math.floor(camY - CAMERA_HEIGHT/2);
      let right = left + CAMERA_WIDTH + 2;
      let bottom = top + CAMERA_HEIGHT + 2;
      let min_cx = Math.floor(left / CHUNK_SIZE);
      let max_cx = Math.floor(right / CHUNK_SIZE);
      let min_cy = Math.floor(top / CHUNK_SIZE);
      let max_cy = Math.floor(bottom / CHUNK_SIZE);
      for(let cx=min_cx; cx<=max_cx; cx++) {
        for(let cy=min_cy; cy<=max_cy; cy++) {
          let probeX = cx*CHUNK_SIZE, probeY = cy*CHUNK_SIZE;
          if(getBlock(probeX, probeY) === null) {
            generateChunk(cx, cy);
          }
        }
      }
    }

    // --- Canvas Setup ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    function resizeCanvas() {
      const DPR = window.devicePixelRatio || 1;
      const minWidthScale  = Math.floor(window.innerWidth  / (CAMERA_WIDTH  * BLOCK_SIZE)) || 1;
      const minHeightScale = Math.floor(window.innerHeight / (CAMERA_HEIGHT * BLOCK_SIZE)) || 1;
      RENDER_SCALE = Math.max(1, Math.min(minWidthScale, minHeightScale));
      const cssWidth  = CAMERA_WIDTH  * BLOCK_SIZE * RENDER_SCALE;
      const cssHeight = CAMERA_HEIGHT * BLOCK_SIZE * RENDER_SCALE;
      canvas.style.width  = cssWidth + "px";
      canvas.style.height = cssHeight + "px";
      canvas.width  = Math.floor(cssWidth * DPR);
      canvas.height = Math.floor(cssHeight * DPR);
      ctx.setTransform(DPR * RENDER_SCALE, 0, 0, DPR * RENDER_SCALE, 0, 0);
      ctx.imageSmoothingEnabled = false;
      ctx.imageSmoothingQuality = "low";
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // --- Player ---
    let player = {
      x: 0,
      y: 0,
      w: 0.7,
      h: 0.95,
      vx: 0, vy: 0,
      onGround: false,
      canJump: true,
      miningCooldown: 0,
      direction: 1, // 1 for right, -1 for left
      characterTexture: null,
      characterPreset: null,
      isMoving: false,
      animationFrame: 0,
      lastAnimationTime: 0
    };

    function findGroundStartX(x) {
      for(let y=-CAMERA_HEIGHT; y<100; y++) {
        let t = getBlock(x, y);
        if(t === null) {
          let cx = Math.floor(x/CHUNK_SIZE), cy = Math.floor(y/CHUNK_SIZE);
          generateChunk(cx, cy);
          t = getBlock(x, y);
        }
        if(t !== "air") return y-1;
      }
      return 0;
    }
    player.x = 0;
    player.y = findGroundStartX(0);

    // --- Camera ---
    let camera = {
      x: player.x,
      y: player.y
    };

    // --- Admin state ---
    const admin = {
      authenticated: false,
      dynamine: false,
      noclip: false,
      fly: false
    };

    // Try restore auth (so a reload won't leak password, only a saved flag)
    try {
      const saved = localStorage.getItem("terr_admin_authed");
      if (saved === "1") admin.authenticated = true;
    } catch (e) {}

    // --- New Inventory System ---
    class Inventory {
      constructor() {
        this.slots = [];
        this.maxSlots = 40;
        this.maxStackSize = 99;
        this.selectedSlot = 0;
        
        // Initialize with default items
        for (let i = 0; i < this.maxSlots; i++) {
          this.slots.push({ type: null, count: 0 });
        }
      }
      
      // Add items to inventory
      addItem(type, count = 1) {
        // Try to stack with existing items first
        for (let i = 0; i < this.slots.length; i++) {
          if (this.slots[i].type === type && this.slots[i].count < this.maxStackSize) {
            const space = this.maxStackSize - this.slots[i].count;
            const toAdd = Math.min(count, space);
            this.slots[i].count += toAdd;
            count -= toAdd;
            if (count <= 0) return true;
          }
        }
        
        // Add to new slots
        for (let i = 0; i < this.slots.length; i++) {
          if (this.slots[i].type === null) {
            const toAdd = Math.min(count, this.maxStackSize);
            this.slots[i].type = type;
            this.slots[i].count = toAdd;
            count -= toAdd;
            if (count <= 0) return true;
          }
        }
        
        return false; // Inventory full
      }
      
      // Remove items from inventory
      removeItem(type, count = 1) {
        for (let i = 0; i < this.slots.length; i++) {
          if (this.slots[i].type === type) {
            const toRemove = Math.min(count, this.slots[i].count);
            this.slots[i].count -= toRemove;
            if (this.slots[i].count <= 0) {
              this.slots[i].type = null;
            }
            count -= toRemove;
            if (count <= 0) return true;
          }
        }
        return false; // Not enough items
      }
      
      // Get item count
      getItemCount(type) {
        let count = 0;
        for (let i = 0; i < this.slots.length; i++) {
          if (this.slots[i].type === type) {
            count += this.slots[i].count;
          }
        }
        return count;
      }
      
      // Get slot at index
      getSlot(index) {
        return this.slots[index];
      }
      
      // Set slot at index
      setSlot(index, type, count) {
        this.slots[index].type = type;
        this.slots[index].count = count;
      }
      
      // Get selected slot
      getSelectedSlot() {
        return this.slots[this.selectedSlot];
      }
      
      // Set selected slot
      setSelectedSlot(index) {
        if (index >= 0 && index < this.slots.length) {
          this.selectedSlot = index;
        }
      }
      
      // Get all items for display
      getAllItems() {
        const items = [];
        for (let i = 0; i < this.slots.length; i++) {
          if (this.slots[i].type !== null) {
            items.push({ index: i, type: this.slots[i].type, count: this.slots[i].count });
          }
        }
        return items;
      }
    }

    // Create inventory instance
    const inventory = new Inventory();

    

    function showInventory() {
      const invDiv = document.getElementById('inventoryPanel');
      invDiv.style.display = "block";
      updateInventoryDisplay();
    }
    
    function hideInventory() {
      document.getElementById('inventoryPanel').style.display = "none";
    }
    
    function updateInventoryDisplay() {
      const slotsDiv = document.getElementById('inventorySlots');
      slotsDiv.innerHTML = '';
      
      // Create 10x4 grid for inventory slots
      for (let i = 0; i < 40; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.dataset.index = i;
        
        // Add key indicator
        const keyIndicator = document.createElement('div');
        keyIndicator.className = 'slot-key';
        keyIndicator.textContent = i < 9 ? i + 1 : '';
        slot.appendChild(keyIndicator);
        
        const item = inventory.getSlot(i);
        if (item.type) {
          const itemElement = document.createElement('div');
          itemElement.className = 'slot-item';
          itemElement.style.background = COLORS[item.type] || '#888';
          itemElement.textContent = item.count > 1 ? item.count : '';
          
          const countElement = document.createElement('div');
          countElement.className = 'slot-count';
          countElement.textContent = item.count > 1 ? item.count : '';
          
          slot.appendChild(itemElement);
          slot.appendChild(countElement);
        }
        
        slot.onclick = () => {
          // Handle slot click (for swapping items)
          if (item.type) {
            // For now, just show item details
            const message = document.getElementById('adminMessage');
            if (message) {
              message.textContent = `Item: ${item.type} (${item.count})`;
              setTimeout(() => {
                if (message.textContent.includes("Item:")) {
                  message.textContent = "";
                }
              }, 2000);
            }
          }
        };
        
        slotsDiv.appendChild(slot);
      }
    }
    
    let inventoryOpen = false;

    // --- Crafting System ---
    let craftingRecipes = [];
    let itemTextures = {};

    // Load crafting data from external files
    async function loadCraftingData() {
      try {
        // Load recipes
        const recipesResponse = await fetch('crafting.json');
        const recipesData = await recipesResponse.json();
        craftingRecipes = recipesData.recipes || [];
        
        // Load textures
        const texturesResponse = await fetch('textures.json');
        const texturesData = await texturesResponse.json();
        itemTextures = texturesData.textures || {};
        
        console.log("Crafting data loaded successfully");
        updateCraftingDisplay();
      } catch (error) {
        console.error("Failed to load crafting data:", error);
        // Fallback to default recipes
        craftingRecipes = [
          {
            name: "Wooden Plank",
            ingredients: [{ type: "wood", count: 1 }],
            result: { type: "plank", count: 4 }
          },
          {
            name: "Brick",
            ingredients: [{ type: "clay", count: 4 }],
            result: { type: "brick", count: 1 }
          },
          {
            name: "Stone Pickaxe",
            ingredients: [
              { type: "stone", count: 3 },
              { type: "wood", count: 2 }
            ],
            result: { type: "pickaxe", count: 1 }
          },
          {
            name: "Stone Sword",
            ingredients: [
              { type: "stone", count: 2 },
              { type: "wood", count: 1 }
            ],
            result: { type: "sword", count: 1 }
          },
          {
            name: "Sandstone",
            ingredients: [
              { type: "sand", count: 4 }
            ],
            result: { type: "sandstone", count: 1 }
          }
        ];
        
        itemTextures = {
          "plank": "#8B4513",
          "pickaxe": "#888",
          "sword": "#C0C0C0",
          "sandstone": "#E8E2AA"
        };
        
        updateCraftingDisplay();
      }
    }

    function updateCraftingDisplay() {
      const recipesDiv = document.getElementById('craftingRecipes');
      recipesDiv.innerHTML = '';
      
      if (craftingRecipes.length === 0) {
        recipesDiv.innerHTML = '<div style="text-align:center; opacity:0.7; padding:20px;">No recipes available</div>';
        return;
      }
      
      craftingRecipes.forEach(recipe => {
        const recipeElement = document.createElement('div');
        recipeElement.className = 'recipe-item';
        recipeElement.innerHTML = `
          <div class="recipe-icon" style="background:${COLORS[recipe.result.type] || itemTextures[recipe.result.type] || '#888'}">
            ${recipe.result.count}
          </div>
          <div class="recipe-details">
            <div class="recipe-name">${recipe.name}</div>
            <div class="recipe-ingredients">
              ${recipe.ingredients.map(ing => 
                `${ing.count} ${ing.type}`
              ).join(' + ')}
            </div>
            <div class="recipe-result">→ ${recipe.result.count} ${recipe.result.type}</div>
          </div>
        `;
        
        recipeElement.onclick = () => {
          craftItem(recipe);
        };
        
        recipesDiv.appendChild(recipeElement);
      });
    }

    function craftItem(recipe) {
      // Check if player has required ingredients
      let canCraft = true;
      for (const ingredient of recipe.ingredients) {
        if (inventory.getItemCount(ingredient.type) < ingredient.count) {
          canCraft = false;
          break;
        }
      }
      
      if (!canCraft) {
        alert("Not enough materials to craft this item!");
        return;
      }
      
      // Remove ingredients
      for (const ingredient of recipe.ingredients) {
        inventory.removeItem(ingredient.type, ingredient.count);
      }
      
      // Add result
      inventory.addItem(recipe.result.type, recipe.result.count);
      
      // Update UI
      updateInventoryDisplay();
      updateCraftingDisplay();
      
      // Show crafting success message
      const message = document.getElementById('adminMessage');
      if (message) {
        message.textContent = `Crafted ${recipe.result.count} ${recipe.result.type}!`;
        setTimeout(() => {
          if (message.textContent.includes("Crafted")) {
            message.textContent = "";
          }
        }, 3000);
      }
    }

    function showCrafting() {
      document.getElementById('craftingPanel').style.display = "block";
    }
    
    function hideCrafting() {
      document.getElementById('craftingPanel').style.display = "none";
    }

    // --- Character Customization (Hardcoded Presets) ---
    const characterPresets = {
      default: {
        name: "Default",
        color: "#fff1c1",
        idleTexture: "https://github.com/Skaberson/Terrandia/blob/main/images/character/default/Barbarian.png?raw=true",
        movingTexture: "https://raw.githubusercontent.com/Skaberson/Terrandia/main/images/character/default/Barbarianmove.gif"
      },
      warrior: {
        name: "Warrior",
        color: "#8B4513",
        idleTexture: "https://raw.githubusercontent.com/Skaberson/test123/images/Warrior.png",
        movingTexture: "https://raw.githubusercontent.com/Skaberson/test123/images/character/Warrior.png"
      },
      mage: {
        name: "Mage",
        color: "#4169E1",
        idleTexture: "https://raw.githubusercontent.com/Skaberson/test123/images/character/Mage.png",
        movingTexture: "https://raw.githubusercontent.com/Skaberson/test123/images/character/Magemove.png"
      },
      archer: {
        name: "Archer",
        color: "#228B22",
        idleTexture: "https://raw.githubusercontent.com/Skaberson/test123/main/images/character/Archer.png",
        movingTexture: "https://raw.githubusercontent.com/Skaberson/test123/main/images/character/Archer.png"
      }
    };

    // Preload character textures
    const characterTextures = {};
    for (const [presetName, preset] of Object.entries(characterPresets)) {
      characterTextures[presetName] = {
        idle: new window.Image(),
        moving: new window.Image()
      };
      
      // Load idle texture
      characterTextures[presetName].idle.src = preset.idleTexture;
      characterTextures[presetName].idle.onload = () => {
        if (!imageCache[presetName + "_idle"]) {
          imageCache[presetName + "_idle"] = {
            img: characterTextures[presetName].idle,
            loaded: true,
            error: false
          };
        }
      };
      characterTextures[presetName].idle.onerror = () => {
        if (!imageCache[presetName + "_idle"]) {
          imageCache[presetName + "_idle"] = {
            img: null,
            loaded: false,
            error: true
          };
        }
      };
      
      // Load moving texture
      characterTextures[presetName].moving.src = preset.movingTexture;
      characterTextures[presetName].moving.onload = () => {
        if (!imageCache[presetName + "_moving"]) {
          imageCache[presetName + "_moving"] = {
            img: characterTextures[presetName].moving,
            loaded: true,
            error: false
          };
        }
      };
      characterTextures[presetName].moving.onerror = () => {
        if (!imageCache[presetName + "_moving"]) {
          imageCache[presetName + "_moving"] = {
            img: null,
            loaded: false,
            error: true
          };
        }
      };
    }

    function applyCharacterPreset(presetName) {
      if (characterPresets[presetName]) {
        player.characterPreset = presetName;
        player.characterTexture = null; // Will use color-based rendering
        
        // Update preview
        updateCharacterPreview();
        
        // Show success message
        const message = document.getElementById('adminMessage');
        if (message) {
          message.textContent = `Character preset "${characterPresets[presetName].name}" applied!`;
          setTimeout(() => {
            if (message.textContent.includes("Character preset")) {
              message.textContent = "";
            }
          }, 3000);
        }
      }
    }

    function showCharacterPanel() {
      document.getElementById('characterPanel').style.display = "block";
      updateCharacterPreview();
    }
    
    function hideCharacterPanel() {
      document.getElementById('characterPanel').style.display = "none";
    }
    
    function updateCharacterPreview() {
      const previewImg = document.getElementById('characterPreviewImg');
      if (player.characterPreset) {
        const preset = characterPresets[player.characterPreset];
        // Create a simple SVG preview
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
          <rect width="100" height="100" fill="#222"/>
          <circle cx="50" cy="40" r="15" fill="${preset.color}"/>
          <rect x="30" y="60" width="40" height="30" fill="${preset.color}"/>
        </svg>`;
        previewImg.src = "data:image/svg+xml," + encodeURIComponent(svg);
      } else {
        // Default character
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
          <rect width="100" height="100" fill="#222"/>
          <circle cx="50" cy="40" r="15" fill="#fff1c1"/>
          <rect x="30" y="60" width="40" height="30" fill="#fff1c1"/>
        </svg>`;
        previewImg.src = "data:image/svg+xml," + encodeURIComponent(svg);
      }
    }

    // --- Terraria-style mining reach check ---
    function isInReach(x, y) {
      let px = player.x;
      let py = player.y + player.h/2;
      let dist = Math.sqrt((x+0.5-px)**2 + (y+0.5-py)**2);
      return dist <= MINE_REACH;
    }

    // --- Hotbar UI ---
    let hotbarSelected = 0;
    function updateHotbar() {
      const hotbar = document.getElementById('hotbar');
      hotbar.innerHTML = "";
      for(let i=0;i<HOTBAR_BLOCKS.length;i++) {
        const block = HOTBAR_BLOCKS[i];
        const slot = document.createElement('div');
        slot.className = "hotbar-slot" + (i===hotbarSelected?" selected":"");
        const count = inventory.getItemCount(block);
        slot.innerHTML = `
          <div class="slot-key">${i+1}</div>
          <div class="slot-swatch" style="background:${COLORS[block]}"></div>
          <span>${block}</span>
          <span class="slot-count">${count || 0}</span>
        `;
        slot.onclick = ()=>{
          hotbarSelected = i;
          updateHotbar();
        };
        hotbar.appendChild(slot);
      }
    }
    updateHotbar();

    // --- Mining and Placement with toughness & cracks ---
    function getMouseTile(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      
      // Use the exact same scaling that's applied to the canvas
      const transform = ctx.getTransform();
      const scale = transform.a; // This should be DPR * RENDER_SCALE
      
      const blockX = Math.floor(x / (BLOCK_SIZE * scale));
      const blockY = Math.floor(y / (BLOCK_SIZE * scale));
      
      // Calculate world coordinates directly without any offset
      let worldX = Math.floor(camera.x - CAMERA_WIDTH / 2 + blockX);
      let worldY = Math.floor(camera.y - CAMERA_HEIGHT / 2 + blockY);
      
      return { x: worldX, y: worldY };
    }

    // Mining state: one block at a time
    let mining = {
      active: false,
      x: null,
      y: null,
      startTime: null,
      duration: null,
      blockType: null,
      mouseButton: null
    };

    let mouseDown = false;
    let mouseButton = null;

    function handlePlace(tile) {
      let t = getBlock(tile.x, tile.y);
      let placeBlock = HOTBAR_BLOCKS[hotbarSelected];
      const count = inventory.getItemCount(placeBlock);
      if(t === 'air' && count > 0) {
        let adjacentSolid = false;
        for(let [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
          let nx = tile.x+dx, ny = tile.y+dy;
          let nt = getBlock(nx, ny);
          if(nt && nt != 'air') {
            adjacentSolid = true;
            break;
          }
        }
        if(adjacentSolid) {
          setBlock(tile.x, tile.y, placeBlock);
          inventory.removeItem(placeBlock, 1);
          updateHotbar();
          updateInventoryDisplay();
        }
      }
    }

    function validToMine(type) {
      if(!type) return false;
      if(type === 'air') return false;
      if(type.endsWith("_bg")) return false;
      if((TOUGHNESS[type] || 0) <= 0) return false;
      return true;
    }

    function areaMine(centerX, centerY) {
      // Remove a 3x3 area centered at centerX, centerY
      let removed = 0;
      for(let dx=-1; dx<=1; dx++) {
        for(let dy=-1; dy<=1; dy++) {
          let bx = centerX + dx;
          let by = centerY + dy;
          let t = getBlock(bx, by);
          if(validToMine(t) && isInReach(bx, by)) {
            setBlock(bx, by, 'air');
            inventory.addItem(t, 1);
            removed++;
          }
        }
      }
      return removed;
    }

    function startMining(tile) {
      if (!isInReach(tile.x, tile.y)) return;
      let t = getBlock(tile.x, tile.y);
      if(!t || t === 'air' || TOUGHNESS[t] === 0 || t.endsWith("_bg")) return;
      if(mining.active && mining.x === tile.x && mining.y === tile.y) return;

      // If admin dynamine is enabled, instantly mine a 3x3 area
      if (admin.authenticated && admin.dynamine) {
        areaMine(tile.x, tile.y);
        // provide small visual feedback by briefly setting mining state
        mining.active = true;
        mining.x = tile.x;
        mining.y = tile.y;
        mining.startTime = performance.now();
        mining.duration = 120; // very short
        mining.blockType = null;
        mining.mouseButton = 0;
        return;
      }

      mining.active = true;
      mining.x = tile.x;
      mining.y = tile.y;
      mining.startTime = performance.now();
      mining.duration = (TOUGHNESS[t] || 1.0) * 1000;
      mining.blockType = t;
      mining.mouseButton = 0;
    }

    function stopMining() {
      mining.active = false;
      mining.x = null;
      mining.y = null;
      mining.startTime = null;
      mining.duration = null;
      mining.blockType = null;
      mining.mouseButton = null;
    }

    canvas.addEventListener('mousedown', (e)=>{
      if (inventoryOpen) return;
      mouseDown = true;
      mouseButton = e.button;
      const mouseTile = getMouseTile(e.clientX, e.clientY);
      if (mouseButton === 0) { // left
        startMining(mouseTile);
      }
      else if (mouseButton === 2) { // right
        handlePlace(mouseTile);
      }
      canvas.focus();
    });

    canvas.addEventListener('mouseup', ()=>{
      mouseDown = false;
      mouseButton = null;
      stopMining();
    });

    canvas.addEventListener('mouseleave', ()=>{
      mouseDown = false;
      mouseButton = null;
      stopMining();
    });

    canvas.addEventListener('mousemove', (e)=>{
      if (inventoryOpen) return;
      const mouseTile = getMouseTile(e.clientX, e.clientY);
      if (!mouseDown) {
        stopMining();
        return;
      }
      if (mouseButton === 0) { // left
        startMining(mouseTile);
      }
      else if (mouseButton === 2) { // right
        handlePlace(mouseTile);
      }
    });

    canvas.addEventListener('contextmenu', e=>e.preventDefault());

    // --- Controls ---
    let left = false, right = false, up = false, down = false, jumpRequest = false;
    function handleKeydown(e) {
      if (e.repeat) return;
      if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') left = true;
      if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') right = true;
      if(e.key==='ArrowUp' || e.key==='w' || e.key==='W') {
        up = true; jumpRequest = true;
      }
      if(e.key==='ArrowDown' || e.key==='s' || e.key==='S') down = true;
      if(e.key===' ' ) { up = true; jumpRequest = true; }
      if(e.key==='i' || e.key==='I') {
        inventoryOpen = !inventoryOpen;
        if(inventoryOpen) showInventory();
        else hideInventory();
      }
      if(e.key==='c' || e.key==='C') {
        showCrafting();
      }
      if(e.key==='x' || e.key==='X') {
        showCharacterPanel();
      }
      // Admin panel toggle (press P)
      if(e.key==='p' || e.key==='P') {
        toggleAdminPanel();
      }
      if(/[1-9]/.test(e.key)) {
        let idx = parseInt(e.key)-1;
        if(idx >= 0 && idx < HOTBAR_BLOCKS.length) {
          hotbarSelected = idx;
          updateHotbar();
        }
      }
    }
    function handleKeyup(e) {
      if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') left = false;
      if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') right = false;
      if(e.key==='ArrowUp' || e.key==='w' || e.key==='W' || e.key===' ') up = false;
      if(e.key==='ArrowDown' || e.key==='s' || e.key==='S') down = false;
    }
    document.addEventListener('keydown', handleKeydown);
    document.addEventListener('keyup', handleKeyup);

    function isSolid(x, y) {
      // Admin noclip bypasses solidity
      if (admin.authenticated && admin.noclip) return false;
      let t = getBlock(x, y);
      return t && t !== 'air' && !t.endsWith("_bg");
    }

    function collideAABB(px, py, vx, vy, w, h) {
      let nx = px, ny = py;
      let onGround = false;
      nx += vx;
      let minY = Math.floor(ny + 1e-8), maxY = Math.floor(ny + h - 1e-8);
      if(vx > 0) {
        let rx = nx + w/2 - 1e-8;
        let xBlock = Math.floor(rx);
        for(let y = minY; y <= maxY; y++) {
          if(isSolid(xBlock, y)) {
            nx = xBlock - w/2;
            break;
          }
        }
      } else if(vx < 0) {
        let lx = nx - w/2 + 1e-8;
        let xBlock = Math.floor(lx);
        for(let y = minY; y <= maxY; y++) {
          if(isSolid(xBlock, y)) {
            nx = xBlock + 1 + w/2 - 1e-8;
            break;
          }
        }
      }
      ny += vy;
      let minX = Math.floor(nx - w/2 + 1e-8), maxX = Math.floor(nx + w/2 - 1e-8);
      if(vy > 0) {
        let by = ny + h - 1e-8;
        let yBlock = Math.floor(by);
        for(let x = minX; x <= maxX; x++) {
          if(isSolid(x, yBlock)) {
            ny = yBlock - h;
            onGround = true;
            break;
          }
        }
      } else if(vy < 0) {
        let ty = ny + 1e-8;
        let yBlock = Math.floor(ty);
        for(let x = minX; x <= maxX; x++) {
          if(isSolid(x, yBlock)) {
            ny = yBlock + 1;
            break;
          }
        }
      }
      return {x: nx, y: ny, onGround};
    }

    let jumpActive = false;
    let jumpTimer = 0;
    const JUMP_DURATION = 0.34;

    function update() {
      ensureWorldGenerated(camera.x, camera.y);
      let targetVx = 0;
      if(left) targetVx -= MOVE_SPEED;
      if(right) targetVx += MOVE_SPEED;
      player.vx += (targetVx - player.vx) * 0.25;

      // Update player direction based on movement
      if (right) player.direction = 1;
      if (left) player.direction = -1;

      // Update movement state for animation
      player.isMoving = (left || right) && !player.onGround;
      
      // Update animation frame
      const now = performance.now();
      if (now - player.lastAnimationTime > 150) { // Update every 150ms
        player.animationFrame = (player.animationFrame + 1) % 2;
        player.lastAnimationTime = now;
      }

      // Admin fly handling
      if (admin.authenticated && admin.fly) {
        // Fly: ignore normal gravity; use up/down keys to go up/down
        if (up) player.vy = -MOVE_SPEED;
        else if (down) player.vy = MOVE_SPEED;
        else player.vy = 0;
      } else {
        if(jumpRequest && player.onGround && !jumpActive) {
          jumpActive = true;
          jumpTimer = 0;
        }
        jumpRequest = false;
        let vy = player.vy;
        if(jumpActive) {
          jumpTimer += TICK;
          let t = jumpTimer/JUMP_DURATION;
          if(t < 1) {
            vy = -JUMP_VEL*(1-t);
          } else {
            jumpActive = false;
          }
        } else {
          vy += GRAVITY;
        }
        player.vy = vy;
      }

      if (admin.authenticated && admin.fly) {
        // use already-set player.vy from fly handling
      }

      let move = collideAABB(player.x, player.y, player.vx*TICK, player.vy*TICK, player.w, player.h);
      player.x = move.x;
      player.y = move.y;
      player.onGround = move.onGround;
      if(player.onGround) {
        player.vy = 0;
        jumpActive = false;
      }

      player.y = Math.max(-CAMERA_HEIGHT, player.y);
      let camTargetX = player.x;
      let camTargetY = player.y;
      camera.x += (camTargetX - camera.x) * 0.12;
      camera.y += (camTargetY - camera.y) * 0.12;

      // Mining completion handling
      if (mining.active && mining.duration != null) {
        let now = performance.now();
        let progress = (now - mining.startTime) / mining.duration;
        if (progress >= 1) {
          // If dynamine was not used for the start, complete the one block normally
          if (!(admin.authenticated && admin.dynamine && mining.duration <= 120)) {
            // normal single-block mining
            if (mining.blockType) {
              setBlock(mining.x, mining.y, 'air');
              inventory.addItem(mining.blockType, 1);
            }
          } else {
            // If admin had dynamine, we already did areaMine on start; but in case mining was set as short duration,
            // don't duplicate actions (we set mining.blockType to null for the short admin run), so nothing here.
          }
          stopMining();
        }
      }
    }

    function drawPlayer() {
      let camX = camera.x - CAMERA_WIDTH/2;
      let camY = camera.y - CAMERA_HEIGHT/2;
      
      let sx = (player.x - camX - player.w/2) * BLOCK_SIZE;
      let sy = (player.y - camY) * BLOCK_SIZE;
      
      // Draw character with preset if available
      if (player.characterPreset) {
        const preset = characterPresets[player.characterPreset];
        
        // Check if we have a texture to use
        const idleTexture = imageCache[player.characterPreset + "_idle"];
        const movingTexture = imageCache[player.characterPreset + "_moving"];
        
        if (idleTexture && idleTexture.loaded && movingTexture && movingTexture.loaded) {
          // Draw the appropriate texture based on movement state
          const texture = player.isMoving ? movingTexture.img : idleTexture.img;
          const width = player.w * BLOCK_SIZE;
          const height = player.h * BLOCK_SIZE;
          
          // Flip the image based on direction
          ctx.save();
          if (player.direction === -1) {
            ctx.translate(sx + width, 0);
            ctx.scale(-1, 1);
          }
          ctx.drawImage(texture, sx, sy, width, height);
          ctx.restore();
        } else {
          // Fallback to color rendering
          // Draw character with animation
          if (player.isMoving) {
            // Use moving animation (alternating frames)
            if (player.animationFrame === 0) {
              // Draw moving frame
              ctx.fillStyle = preset.color;
              ctx.fillRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
              ctx.strokeStyle = "#000";
              ctx.lineWidth = 2;
              ctx.strokeRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
            } else {
              // Draw idle frame
              ctx.fillStyle = preset.color;
              ctx.fillRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
              ctx.strokeStyle = "#000";
              ctx.lineWidth = 2;
              ctx.strokeRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
            }
          } else {
            // Draw idle frame
            ctx.fillStyle = preset.color;
            ctx.fillRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
          }
        }
      } else {
        // Draw default player if no preset
        ctx.fillStyle = COLORS.player;
        ctx.fillRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
      }
    }

    function draw() {
      let camX = camera.x - CAMERA_WIDTH/2;
      let camY = camera.y - CAMERA_HEIGHT/2;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Draw background blocks, then foreground blocks
      let left = Math.floor(camX), top = Math.floor(camY);
      // Background pass
      for(let x=left; x<=left+CAMERA_WIDTH; x++) {
        for(let y=top; y<=top+CAMERA_HEIGHT; y++) {
          let t = getBackground(x, y);
          if(t) {
            let px = (x - camX) * BLOCK_SIZE;
            let py = (y - camY) * BLOCK_SIZE;
            let size = BLOCK_SIZE * BACKGROUND_BLOCK_SCALE;
            let adjust = (size - BLOCK_SIZE) / 2;
            if (
              BLOCK_IMAGES[t] &&
              imageCache[t] &&
              imageCache[t].loaded &&
              !imageCache[t].error
            ) {
              ctx.drawImage(imageCache[t].img, px - adjust, py - adjust, size, size);
            } else {
              ctx.fillStyle = COLORS[t] || "#222";
              ctx.fillRect(px - adjust, py - adjust, size, size);
            }
          }
        }
      }
      // Foreground pass
      for(let x=left; x<=left+CAMERA_WIDTH; x++) {
        for(let y=top; y<=top+CAMERA_HEIGHT; y++) {
          let t = getBlock(x, y);
          if(t && t !== "air") {
            let px = (x - camX) * BLOCK_SIZE;
            let py = (y - camY) * BLOCK_SIZE;
            let size = BLOCK_SIZE * BLOCK_SCALE;
            let adjust = (size - BLOCK_SIZE) / 2;
            if (
              BLOCK_IMAGES[t] &&
              imageCache[t] &&
              imageCache[t].loaded &&
              !imageCache[t].error
            ) {
              ctx.drawImage(imageCache[t].img, px - adjust, py - adjust, size, size);
            } else {
              ctx.fillStyle = COLORS[t] || "#ff00ff";
              ctx.fillRect(px - adjust, py - adjust, size, size);
            }
            if (mining.active && mining.x === x && mining.y === y && crackLoaded) {
              let now = performance.now();
              let progress = Math.min(1, (now - mining.startTime) / (mining.duration || 200));
              let crackScale = lerp(0.3, 1.0, progress);
              let crackSize = BLOCK_SIZE * crackScale;
              let crackAdjust = (crackSize - BLOCK_SIZE) / 2;
              ctx.save();
              ctx.globalAlpha = 0.35 + 0.65 * progress;
              ctx.drawImage(crackImg,
                px - crackAdjust,
                py - crackAdjust,
                crackSize,
                crackSize
              );
              ctx.restore();
            }
          }
        }
      }
      
      // Draw player
      drawPlayer();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    // ----------------
    // Fullscreen toggle
    // ----------------
    const fullscreenButton = document.getElementById('fullscreenButton');
    fullscreenButton.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.error(`Error attempting to enable fullscreen: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    });

    // Handle fullscreen change to maintain proper layout
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        // In fullscreen mode, make canvas fill the screen properly
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        resizeCanvas();
      } else {
        // Exit fullscreen - restore normal sizing
        resizeCanvas();
      }
    });

    // ----------------
    // Character Panel Controls
    // ----------------
    document.getElementById('closeCharacter').addEventListener('click', hideCharacterPanel);
    
    // Add event listeners for character presets
    document.querySelectorAll('.preset-btn').forEach(button => {
      button.addEventListener('click', () => {
        const preset = button.dataset.preset;
        applyCharacterPreset(preset);
      });
    });

    // ----------------
    // Crafting UI Controls
    // ----------------
    document.getElementById('closeCrafting').addEventListener('click', hideCrafting);
    
    // ----------------
    // Admin panel logic
    // ----------------
    const adminPanel = document.getElementById('adminPanel');
    const adminLoginDiv = document.getElementById('adminLogin');
    const adminControlsDiv = document.getElementById('adminControls');
    const adminPasswordInput = document.getElementById('adminPassword');
    const adminLoginBtn = document.getElementById('adminLoginBtn');
    const adminLoginMsg = document.getElementById('adminLoginMsg');
    const adminMessage = document.getElementById('adminMessage');

    const dynamineToggle = document.getElementById('dynamineToggle');
    const noclipToggle = document.getElementById('noclipToggle');
    const flyToggle = document.getElementById('flyToggle');
    const give99Btn = document.getElementById('give99Btn');
    const teleportBtn = document.getElementById('teleportBtn');
    const closeAdminBtn = document.getElementById('closeAdminBtn');
    const logoutAdminBtn = document.getElementById('logoutAdminBtn');
    const clear5Btn = document.getElementById('clear5Btn');

    // initialize toggles from admin state
    function refreshAdminUI() {
      dynamineToggle.checked = !!admin.dynamine;
      noclipToggle.checked = !!admin.noclip;
      flyToggle.checked = !!admin.fly;
      if (admin.authenticated) {
        adminLoginDiv.style.display = "none";
        adminControlsDiv.style.display = "block";
        adminPanel.setAttribute("aria-hidden", "false");
      } else {
        adminLoginDiv.style.display = "block";
        adminControlsDiv.style.display = "none";
        adminPanel.setAttribute("aria-hidden", "true");
      }
    }
    refreshAdminUI();

    function openAdminPanel() {
      adminPanel.style.display = "block";
      adminPanel.style.opacity = "1";
      if (admin.authenticated) {
        adminPasswordInput.value = "";
      } else {
        adminPasswordInput.value = "";
        adminPasswordInput.focus();
      }
      refreshAdminUI();
    }
    function closeAdminPanel() {
      adminPanel.style.display = "none";
    }
    function toggleAdminPanel() {
      if (adminPanel.style.display === "block") {
        closeAdminPanel();
      } else {
        openAdminPanel();
      }
    }

    adminLoginBtn.addEventListener('click', ()=>{
      const val = adminPasswordInput.value || "";
      if (val === ADMIN_PASSWORD) {
        admin.authenticated = true;
        try { localStorage.setItem("terr_admin_authed", "1"); } catch (e){}
        adminLoginMsg.textContent = "";
        adminMessage.textContent = "Welcome, admin.";
        refreshAdminUI();
      } else {
        adminLoginMsg.textContent = "Incorrect password.";
      }
    });

    dynamineToggle.addEventListener('change', (e)=>{
      admin.dynamine = !!e.target.checked;
      adminMessage.textContent = "Dynamine " + (admin.dynamine ? "enabled" : "disabled") + ".";
    });
    noclipToggle.addEventListener('change', (e)=>{
      admin.noclip = !!e.target.checked;
      adminMessage.textContent = "Noclip " + (admin.noclip ? "enabled" : "disabled") + ".";
    });
    flyToggle.addEventListener('change', (e)=>{
      admin.fly = !!e.target.checked;
      adminMessage.textContent = "Fly " + (admin.fly ? "enabled" : "disabled") + ".";
    });

    give99Btn.addEventListener('click', ()=>{
      const block = HOTBAR_BLOCKS[hotbarSelected];
      inventory.addItem(block, 99);
      updateHotbar();
      updateInventoryDisplay();
      adminMessage.textContent = `Gave 99 x ${block}.`;
    });

    teleportBtn.addEventListener('click', ()=>{
      player.x = 0;
      player.y = findGroundStartX(0);
      camera.x = player.x;
      camera.y = player.y;
      adminMessage.textContent = "Teleported to spawn.";
    });
    
    // Add these after the existing teleportBtn.addEventListener in the JavaScript:
teleportBiomesBtn.addEventListener('click', ()=>{
  // Teleport to a random biome location
  const biomeX = Math.floor(Math.random() * 1000) - 500; // Random x position
  const biomeY = findGroundStartX(biomeX);
  player.x = biomeX;
  player.y = biomeY;
  camera.x = player.x;
  camera.y = player.y;
  adminMessage.textContent = "Teleported to random biome location.";
});

t// Replace the existing teleportSkyBtn.addEventListener with this improved version:
teleportSkyBtn.addEventListener('click', ()=>{
  // Find a sky island near the player
  const playerChunkX = Math.floor(player.x / CHUNK_SIZE);
  const playerChunkY = Math.floor(player.y / CHUNK_SIZE);
  
  // Look for sky islands in nearby chunks
  for (let cx = playerChunkX - 5; cx <= playerChunkX + 5; cx++) {
    for (let cy = playerChunkY - 5; cy <= playerChunkY + 5; cy++) {
      // Check if this chunk contains sky islands
      for (let dx = 0; dx < CHUNK_SIZE; dx++) {
        const x = cx * CHUNK_SIZE + dx;
        if (valueNoise(x, 99999) > 0.985) {
          // Found a potential sky island location
          const skyY = -50 + Math.floor(valueNoise(x*11, seed)*8) - 3;
          player.x = x;
          player.y = skyY;
          camera.x = player.x;
          camera.y = player.y;
          adminMessage.textContent = "Teleported to sky island!";
          return;
        }
      }
    }
  }
  
  // If no sky island found nearby, teleport to a random sky island
  const skyX = Math.floor(Math.random() * 1000) - 500;
  const skyY = -50 + Math.floor(Math.random() * 50) - 25;
  player.x = skyX;
  player.y = skyY;
  camera.x = player.x;
  camera.y = player.y;
  adminMessage.textContent = "Teleported to random sky island.";
});


    clear5Btn.addEventListener('click', ()=>{
      // Clear a 5x5 centered around the player's targeted tile (mouse) or player pos if mouse outside
      const rect = canvas.getBoundingClientRect();
      const mx_css = (rect.left + rect.right) / 2;
      const my_css = (rect.top + rect.bottom) / 2;
      const mouseTile = getMouseTile(mx_css, my_css);
      let cx = mouseTile.x, cy = mouseTile.y;
      // ensure world around exists
      for(let dx=-2; dx<=2; dx++) for(let dy=-2; dy<=2; dy++) {
        const bx = cx+dx, by = cy+dy;
        let t = getBlock(bx, by);
        if(validToMine(t)) {
          setBlock(bx, by, 'air');
          inventory.addItem(t, 1);
        }
      }
      adminMessage.textContent = "Cleared 5x5 and added removed blocks to inventory.";
    });

    closeAdminBtn.addEventListener('click', ()=>{ closeAdminPanel(); });
    logoutAdminBtn.addEventListener('click', ()=>{
      admin.authenticated = false;
      admin.dynamine = false;
      admin.noclip = false;
      admin.fly = false;
      try { localStorage.removeItem("terr_admin_authed"); } catch (e){}
      adminMessage.textContent = "Logged out.";
      refreshAdminUI();
    });

    // Small UX: press Enter in password field
    adminPasswordInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') adminLoginBtn.click();
    });

    // If page loads and admin was authed from previous session, refresh UI
    if (admin.authenticated) {
      refreshAdminUI();
    }

    // Load crafting data when page loads
    loadCraftingData();
  </script>
</body>
</html>
