<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Terrandia</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #222;}
    body { width: 100vw; height: 100vh;}
    #menu, #world-gen, #player-gen, #inventoryPanel { font-family: monospace; }
    #menu, #world-gen, #player-gen {
      position: absolute; z-index: 100;
      left: 50vw; top: 45vh; transform: translate(-50%,-50%);
      min-width: 320px; background: #17181d; border-radius: 12px;
      box-shadow: 0 8px 48px #000a; border: 2.5px solid #fffd7f;
      color: #fff; padding: 36px 36px 32px 36px; text-align: center;
      display: none;
    }
    #menu h1 { margin-top:0; margin-bottom:18px; color: #fffd7f; font-size: 38px; letter-spacing: 2px; }
    #menu .subtitle {font-size: 15px; opacity:.6;}
    #menu button, #world-gen button, #player-gen button {
      font-size: 17px; margin: 10px 0; border-radius:5px; border: none; padding: 9px 30px;
      background: #fffd7f; color: #232; font-weight: bold; cursor: pointer;
      box-shadow: 0 2px 8px #0006;
      transition: background .10s;
    }
    #menu button:hover, #world-gen button:hover, #player-gen button:hover {
      background: #ffe13b;
    }
    .input-row { margin: 14px 0;}
    .input-row label { font-size: 15px; margin-right: 9px; }
    .input-row input, .input-row select {
      font-size: 16px; padding:3px 8px; border-radius: 4px; border: 1.2px solid #fffd7f;
      background: #24242a; color: #fff;
      margin-left: 9px;
    }
    .list-btn {
      display:inline-block; margin: 3px 5px; padding: 7px 17px; border-radius: 4px;
      background: #fffd7f; color: #232; cursor:pointer; font-size: 16px; font-weight: bold;
      border: none;
      transition: background .10s;
    }
    .list-btn:hover { background: #ffe13b;}
    #hotbar {
      position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 6px; z-index: 5; pointer-events: none;
    }
    .hotbar-slot {
      width: 38px; height: 38px; border-radius: 7px; border: 2.3px solid #888;
      background: #222c; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; justify-content: center;
      font-family: monospace; font-size: 13px; font-weight: bold; color: #fff; 
      position: relative; transition: border 0.1s, background 0.1s;
      user-select: none;
    }
    .hotbar-slot.selected { border: 2.8px solid #fffd7f; background: #242d; }
    .hotbar-slot .slot-key {
      position: absolute; top: 1px; right: 2px; font-size: 10px; color: #fff7a7; opacity: 0.65;
    }
    .hotbar-slot .slot-count {
      position: absolute; bottom: 2px; right: 4px; font-size: 11px; color: #fff;
      text-shadow: 0 0 2px #000,0 0 4px #000;
      font-weight: normal;
    }
    .hotbar-slot .slot-swatch {
      width: 18px; height: 18px; border-radius: 3px; margin-top: 7px;
      border: 1.2px solid #888;
      margin-bottom: 3px;
      box-sizing: border-box;
    }
    canvas { display: block; background: #223366; }
    #inventoryPanel {
      position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
      background: rgba(16,16,24,0.97); color: #fff; font-family: monospace;
      border: 2px solid #fffd7f; border-radius: 8px; min-width: 270px;
      padding: 18px 30px 18px 30px; z-index: 10; display: none;
      box-shadow: 0 8px 32px #000a;
    }
    #inventoryPanel h2 { margin: 0 0 10px 0; font-size: 18px; text-align: center;}
    #inventoryItems { font-size: 16px; letter-spacing: 1px;}
  </style>
</head>
<body>
  <div id="menu">
    <h1>Terrandia</h1>
    <div class="subtitle">A 2D Procedural Mining Adventure</div>
    <div id="menu-choose">
      <button onclick="showWorldGen()">New World</button>
      <button onclick="showWorldLoad()">Load World</button>
    </div>
    <div id="menu-load" style="display:none"></div>
  </div>
  <div id="world-gen" style="display:none;">
    <h2>World Creation</h2>
    <form id="worldGenForm" onsubmit="event.preventDefault(); startPlayerGen();">
      <div class="input-row">
        <label>World Name:</label>
        <input id="worldNameInput" required maxlength="18" style="width:120px;" value="World1">
      </div>
      <div class="input-row">
        <label>Generation:</label>
        <select id="worldTypeInput">
          <option value="default">Default</option>
          <option value="sandy">Sandy</option>
          <option value="snowy">Snowy</option>
          <option value="clay">Clay</option>
          <option value="mixed">Mixed</option>
        </select>
      </div>
      <button type="submit">Next: Player Creation</button>
    </form>
  </div>
  <div id="player-gen" style="display:none;">
    <h2>Player Creation</h2>
    <form id="playerGenForm" onsubmit="event.preventDefault(); finishPlayerGen();">
      <div class="input-row">
        <label>Player Name:</label>
        <input id="playerNameInput" required maxlength="18" style="width:120px;" value="Player1">
      </div>
      <div class="input-row">
        <label>Color:</label>
        <input type="color" id="playerColorInput" value="#fff1c1">
      </div>
      <button type="submit">Start Game</button>
    </form>
  </div>
  <div id="hotbar"></div>
  <div id="inventoryPanel">
    <h2>Inventory <span style="font-size:12px;opacity:.6">(press I to close)</span></h2>
    <div id="inventoryItems"></div>
  </div>
  <canvas id="game" tabindex="0"></canvas>
  <script>
    // LocalStorage keys
    const WORLDS_KEY = "terr_worlds";
    const PLAYERS_KEY = "terr_players";

    // --- Simple save/load helpers using localStorage ---
    function saveWorldData(name, data) {
      let worlds = JSON.parse(localStorage.getItem(WORLDS_KEY) || "{}");
      worlds[name] = data;
      localStorage.setItem(WORLDS_KEY, JSON.stringify(worlds));
    }
    function loadWorldData(name) {
      let worlds = JSON.parse(localStorage.getItem(WORLDS_KEY) || "{}");
      return worlds[name] || null;
    }
    function getWorldList() {
      return Object.keys(JSON.parse(localStorage.getItem(WORLDS_KEY) || "{}"));
    }
    function savePlayerData(name, data) {
      let players = JSON.parse(localStorage.getItem(PLAYERS_KEY) || "{}");
      players[name] = data;
      localStorage.setItem(PLAYERS_KEY, JSON.stringify(players));
    }
    function loadPlayerData(name) {
      let players = JSON.parse(localStorage.getItem(PLAYERS_KEY) || "{}");
      return players[name] || null;
    }
    function getPlayerList() {
      return Object.keys(JSON.parse(localStorage.getItem(PLAYERS_KEY) || "{}"));
    }

    // --- Menu system ---
    let currentWorld = null, currentPlayer = null;
    function showMenu() {
      document.getElementById("menu").style.display = "block";
      document.getElementById("world-gen").style.display = "none";
      document.getElementById("player-gen").style.display = "none";
      document.getElementById("menu-choose").style.display = "";
      document.getElementById("menu-load").style.display = "none";
      stopGame();
    }
    function showWorldGen() {
      document.getElementById("menu").style.display = "none";
      document.getElementById("world-gen").style.display = "block";
      document.getElementById("player-gen").style.display = "none";
    }
    function showWorldLoad() {
      document.getElementById("menu-choose").style.display = "none";
      let menuLoad = document.getElementById("menu-load");
      menuLoad.innerHTML = "<h2>Choose World</h2>";
      let worlds = getWorldList();
      if (worlds.length === 0) menuLoad.innerHTML += "<div>(no worlds found)</div>";
      for(const w of worlds) {
        menuLoad.innerHTML += `<button class="list-btn" onclick="pickWorld('${w.replace(/'/g,"\\'")}')">${w}</button>`;
      }
      menuLoad.innerHTML += `<br><button onclick="showMenu()">Back</button>`;
      menuLoad.style.display = "";
    }
    function pickWorld(worldName) {
      currentWorld = loadWorldData(worldName);
      // After picking world, pick player
      let menuLoad = document.getElementById("menu-load");
      menuLoad.innerHTML = "<h2>Choose Player</h2>";
      let players = getPlayerList();
      if (players.length === 0) menuLoad.innerHTML += "<div>(no players found)</div>";
      for(const p of players) {
        menuLoad.innerHTML += `<button class="list-btn" onclick="pickPlayer('${p.replace(/'/g,"\\'")}', true)">${p}</button>`;
      }
      menuLoad.innerHTML += `<br><button onclick="showMenu()">Back</button>`;
    }
    function pickPlayer(playerName, playNow) {
      currentPlayer = loadPlayerData(playerName);
      document.getElementById("menu").style.display = "none";
      document.getElementById("menu-load").style.display = "none";
      if (playNow) startGame();
    }
    function startPlayerGen() {
      document.getElementById("world-gen").style.display = "none";
      document.getElementById("player-gen").style.display = "block";
    }
    function finishPlayerGen() {
      let worldName = document.getElementById("worldNameInput").value.trim();
      if (!worldName) return;
      let worldType = document.getElementById("worldTypeInput").value;
      currentWorld = {
        name: worldName,
        type: worldType,
        seed: Math.floor(Math.random()*1000000)
      };
      saveWorldData(worldName, currentWorld);

      let playerName = document.getElementById("playerNameInput").value.trim();
      if (!playerName) return;
      let playerColor = document.getElementById("playerColorInput").value;
      currentPlayer = {
        name: playerName,
        color: playerColor
      };
      savePlayerData(playerName, currentPlayer);

      document.getElementById("player-gen").style.display = "none";
      startGame();
    }
    showMenu();

    // --- GAME STATE ---
    let gameStarted = false;
    let stopGameLoop = false;
    let gameLoopId = null;
    function startGame() {
      stopGame();
      gameStarted = true;
      stopGameLoop = false;
      document.getElementById("menu").style.display = "none";
      document.getElementById("world-gen").style.display = "none";
      document.getElementById("player-gen").style.display = "none";
      document.getElementById("menu-load").style.display = "none";
      // Remove any old event listeners from previous game
      window.onkeydown = null;
      window.onkeyup = null;
      // Set up game with world & player
      TerrandiaGame(currentWorld, currentPlayer);
    }
    function stopGame() {
      stopGameLoop = true;
      if (gameLoopId !== null) cancelAnimationFrame(gameLoopId);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Remove all gameplay event listeners
      window.onkeydown = null;
      window.onkeyup = null;
    }

    // --- TERRANDIA GAME ENGINE ---
    function TerrandiaGame(worldInfo, playerInfo) {
      // --- (Rest of the code: same as before, unchanged) ---
      // [The entire gameplay code block from previous responses goes here, unchanged...]
      // But: attach all event listeners (keydown/up) to window, not document, so you can clean up on menu return.

      // --- Config/Block data/constants (as before) ---
      const BLOCK_SIZE = 24;
      const BLOCK_SCALE = 1.03;
      const CAMERA_WIDTH = 24;
      const CAMERA_HEIGHT = 14;
      const GROUND_LEVEL = 10;
      const GRAVITY = 0.3;
      const JUMP_VEL = 6.8;
      const MOVE_SPEED = 3.2;
      const TICK = 1/60;
      const CHUNK_SIZE = 32;
      const MINE_REACH = 5;
      const COLORS = {
        air: "#223366",
        grass: "#3cbb3c",
        dirt: "#87692b",
        stone: "#888",
        sand: "#e8e2aa",
        clay: "#b97a56",
        snow: "#e0e8f0",
        hotstone: "#c75d35",
        magma: "#f85a0a",
        lava: "#ff4100",
        leaf: "#5ed04b",
        wood: "#7c4f20",
        brick: "#a64832",
        ore: "#e4e45c",
        player: "#fff1c1",
        select: "#fffd7f"
      };
      const HOTBAR_BLOCKS = [
        "dirt", "stone", "sand", "clay", "snow", "hotstone", "magma", "wood", "brick"
      ];
      const BLOCK_IMAGES = {
        grass: "https://raw.githubusercontent.com/Skaberson/test123/main/images/grass.png",
        dirt: "https://raw.githubusercontent.com/Skaberson/test123/main/images/dirt_00.png",
        stone: "https://raw.githubusercontent.com/Skaberson/test123/main/images/stone.png",
        sand: "https://raw.githubusercontent.com/Skaberson/test123/main/images/sand.png",
        clay: "",
        snow: "https://raw.githubusercontent.com/Skaberson/test123/main/images/snow.png",
        hotstone: "",
        magma: "",
        lava: "",
        leaf: "",
        wood: "",
        brick: "",
        ore: ""
      };
      // --- PRNG, perlin, valueNoise, etc: as before ---
      function mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
      }
      function lerp(a, b, t) { return a + (b - a) * t; }
      function smoothstep(t) { return t * t * (3 - 2 * t); }
      function valueNoise(x, seed) {
        let rnd = mulberry32(seed + x*73856093);
        return rnd();
      }
      function perlin1d(x, seed) {
        let xi = Math.floor(x);
        let xf = x - xi;
        let l = valueNoise(xi, seed), r = valueNoise(xi+1, seed);
        return lerp(l, r, smoothstep(xf));
      }
      function getBiome(x) {
        const bseed = 121212;
        const n = perlin1d(x / 64, bseed * 13);
        if (n < 0.25) {
          return { name: "desert", surface: "sand", dirt: "sand", stone: "stone", tree: null };
        } else if (n < 0.48) {
          return { name: "snow", surface: "snow", dirt: "snow", stone: "stone", tree: null };
        } else if (n < 0.75) {
          return { name: "forest", surface: "grass", dirt: "dirt", stone: "stone", tree: "oak" };
        } else {
          return { name: "clay", surface: "clay", dirt: "clay", stone: "stone", tree: null };
        }
      }
      // --- World Storage and generation ---
      let world = {};
      const seed = worldInfo.seed;
      function getBlock(x, y) {
        const key = x + "," + y;
        if(world.hasOwnProperty(key)) return world[key];
        return null;
      }
      function setBlock(x, y, type) {
        world[x+','+y] = type;
      }
      function generateChunk(cx, cy) {
        for(let dx=0; dx<CHUNK_SIZE; dx++) {
          let x = cx * CHUNK_SIZE + dx;
          let biome;
          switch(worldInfo.type) {
            case 'sandy': biome = {name:"desert",surface:"sand",dirt:"sand",stone:"stone",tree:null}; break;
            case 'snowy': biome = {name:"snow",surface:"snow",dirt:"snow",stone:"stone",tree:null}; break;
            case 'clay': biome = {name:"clay",surface:"clay",dirt:"clay",stone:"stone",tree:null}; break;
            case 'mixed':
              biome = getBiome(x + seed*0.13);
              break;
            case 'default':
            default: biome = getBiome(x);
          }
          let h = Math.floor(GROUND_LEVEL + perlin1d(x/8, seed)*7 + perlin1d(x/2, seed*2)*3 + perlin1d(x/18, seed*(biome.name?biome.name.length:1))*2);
          for(let dy=0; dy<CHUNK_SIZE; dy++) {
            let y = cy * CHUNK_SIZE + dy;
            let key = x + "," + y;
            if(world.hasOwnProperty(key)) continue;
            let type = "air";
            let temp = 0.0 + y*0.008;
            let stoneType = "stone";
            if (temp > 2.5) stoneType = "hotstone";
            if (temp > 5.5) stoneType = "magma";
            if (temp > 8.5) stoneType = "lava";
            if(y < h) type = 'air';
            else if(y == h) type = biome.surface;
            else if(y < h+3) type = biome.dirt;
            else type = stoneType;
            if (y > h+1 && type !== 'air' && cave2D(x, y, biome, h)) type = 'air';
            if((type === "stone" || type === "hotstone" || type==="magma") && valueNoise(x + y*31, seed*4) > 0.995) type = "ore";
            if (y === h && valueNoise(Math.floor(x/8), 3333) < 0.025) {
              for (let sx = -2; sx <= 2; sx++) for (let sy = 0; sy < 4; sy++) {
                let wx = x + sx, wy = y - sy;
                if (sy === 0) setBlock(wx, wy, "brick");
                else if (sy === 3) setBlock(wx, wy, "leaf");
                else if (sx === -2 || sx === 2) setBlock(wx, wy, "wood");
                else setBlock(wx, wy, "air");
              }
              setBlock(x, y-1, "air");
            }
            if(biome.tree && y === h && valueNoise(x, 555) > 0.94) {
              setBlock(x, y-1, "wood"); setBlock(x, y-2, "wood");
              setBlock(x, y-3, "leaf");
              setBlock(x-1, y-3, "leaf"); setBlock(x+1, y-3, "leaf");
              setBlock(x, y-4, "leaf");
            }
            world[key] = type;
          }
        }
      }
      function ensureWorldGenerated(camX, camY) {
        let left = Math.floor(camX - CAMERA_WIDTH/2);
        let top = Math.floor(camY - CAMERA_HEIGHT/2);
        let right = left + CAMERA_WIDTH + 2;
        let bottom = top + CAMERA_HEIGHT + 2;
        let min_cx = Math.floor(left / CHUNK_SIZE);
        let max_cx = Math.floor(right / CHUNK_SIZE);
        let min_cy = Math.floor(top / CHUNK_SIZE);
        let max_cy = Math.floor(bottom / CHUNK_SIZE);
        for(let cx=min_cx; cx<=max_cx; cx++) {
          for(let cy=min_cy; cy<=max_cy; cy++) {
            let probeX = cx*CHUNK_SIZE, probeY = cy*CHUNK_SIZE;
            if(getBlock(probeX, probeY) === null) {
              generateChunk(cx, cy);
            }
          }
        }
      }
      function resizeCanvas() {
        canvas.width = CAMERA_WIDTH * BLOCK_SIZE;
        canvas.height = CAMERA_HEIGHT * BLOCK_SIZE;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      let player = {
        x: 0,
        y: 0,
        w: 0.7,
        h: 0.95,
        vx: 0, vy: 0,
        onGround: false,
        canJump: true,
        miningCooldown: 0
      };
      function findGroundStartX(x) {
        for(let y=-CAMERA_HEIGHT; y<100; y++) {
          let t = getBlock(x, y);
          if(t === null) {
            let cx = Math.floor(x/CHUNK_SIZE), cy = Math.floor(y/CHUNK_SIZE);
            generateChunk(cx, cy);
            t = getBlock(x, y);
          }
          if(t !== "air") return y-1;
        }
        return 0;
      }
      player.x = 0;
      player.y = findGroundStartX(0);

      let camera = {
        x: player.x,
        y: player.y
      };

      let inventory = {};
      for(const k of HOTBAR_BLOCKS) inventory[k]=10;
      function addToInventory(blockType, amt=1) {
        if (!inventory.hasOwnProperty(blockType)) inventory[blockType] = 0;
        inventory[blockType] += amt;
        updateHotbar();
      }
      function showInventory() {
        const invDiv = document.getElementById('inventoryPanel');
        invDiv.style.display = "block";
        updateInventoryDisplay();
      }
      function hideInventory() {
        document.getElementById('inventoryPanel').style.display = "none";
      }
      function updateInventoryDisplay() {
        const itemsDiv = document.getElementById('inventoryItems');
        let out = "";
        let hasAny = false;
        for(const k in inventory) {
          if(inventory[k] > 0) {
            out += `<span style="color:${COLORS[k]||'#fff'}">${k}</span>: <b>${inventory[k]}</b><br>`;
            hasAny = true;
          }
        }
        if(!hasAny) out = "<i>(empty)</i>";
        itemsDiv.innerHTML = out;
      }
      let inventoryOpen = false;

      function isInReach(x, y) {
        let px = player.x;
        let py = player.y + player.h/2;
        let dist = Math.sqrt((x+0.5-px)**2 + (y+0.5-py)**2);
        return dist <= MINE_REACH;
      }
      let hotbarSelected = 0;
      function updateHotbar() {
        const hotbar = document.getElementById('hotbar');
        hotbar.innerHTML = "";
        for(let i=0;i<HOTBAR_BLOCKS.length;i++) {
          const block = HOTBAR_BLOCKS[i];
          const slot = document.createElement('div');
          slot.className = "hotbar-slot" + (i===hotbarSelected?" selected":"");
          slot.innerHTML = `
            <div class="slot-key">${i+1}</div>
            <div class="slot-swatch" style="background:${COLORS[block]}"></div>
            <span>${block}</span>
            <span class="slot-count">${inventory[block]||0}</span>
          `;
          slot.onclick = ()=>{ hotbarSelected = i; updateHotbar(); };
          hotbar.appendChild(slot);
        }
      }
      updateHotbar();

      let minedBlocks = 0;
      let mouseTile = null;
      let mouseDown = false, mouseRight = false;
      let mouseTileRefresh = {x: 0, y: 0};
      let mouseTileLast = {x: 0, y: 0};
      let mouseTileTimer = 0;

      function getMouseTile(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        let scaleX = canvas.width / rect.width;
        let scaleY = canvas.height / rect.height;
        let mx = Math.floor((clientX - rect.left) * scaleX / BLOCK_SIZE);
        let my = Math.floor((clientY - rect.top) * scaleY / BLOCK_SIZE);
        let cx = Math.floor(camera.x - CAMERA_WIDTH/2 + mx);
        let cy = Math.floor(camera.y - CAMERA_HEIGHT/2 + my);
        return {x: cx, y: cy};
      }
      canvas.onmousemove = (e)=>{
        mouseTile = getMouseTile(e.clientX, e.clientY);
        mouseTileRefresh = mouseTile;
        mouseTileTimer = 0;
      };
      canvas.onmouseleave = ()=>{ mouseTile = null; };
      canvas.onmousedown = (e)=>{
        if (inventoryOpen) return;
        mouseDown = true;
        mouseRight = e.button === 2;
        attemptMineOrPlace();
        canvas.focus();
      };
      canvas.onmouseup = ()=>{ mouseDown = false; };
      canvas.oncontextmenu = e=>e.preventDefault();

      function periodicMouseTileRefresh() {
        mouseTileTimer += 1;
        if (mouseTile && (mouseTile.x !== mouseTileLast.x || mouseTile.y !== mouseTileLast.y)) {
          mouseTileRefresh = { ...mouseTile };
          mouseTileLast = { ...mouseTile };
          mouseTileTimer = 0;
        } else if (mouseTile && mouseTileTimer >= 60) {
          let rect = canvas.getBoundingClientRect();
          let mx = ((mouseTile.x + CAMERA_WIDTH/2 - camera.x) * BLOCK_SIZE) * (rect.width / canvas.width) + rect.left + 0.1;
          let my = ((mouseTile.y + CAMERA_HEIGHT/2 - camera.y) * BLOCK_SIZE) * (rect.height / canvas.height) + rect.top + 0.1;
          mouseTileRefresh = getMouseTile(mx, my);
          mouseTileTimer = 0;
        }
      }

      function attemptMineOrPlace() {
        if(!mouseTileRefresh) return;
        let {x, y} = mouseTileRefresh;
        if (!isInReach(x, y)) return;
        let t = getBlock(x, y);
        let placeBlock = HOTBAR_BLOCKS[hotbarSelected];
        if(mouseRight) {
          if(t === 'air' && (inventory[placeBlock]||0)>0) {
            for(let [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
              let nx = x+dx, ny = y+dy;
              let nt = getBlock(nx, ny);
              if(nt && nt != 'air') {
                setBlock(x, y, placeBlock);
                inventory[placeBlock]--;
                updateHotbar();
                updateInventoryDisplay();
                break;
              }
            }
          }
        } else {
          if(t && t !== 'air') {
            setBlock(x, y, 'air');
            minedBlocks++;
            addToInventory(t, 1);
            updateHotbar();
            updateInventoryDisplay();
          }
        }
      }

      let left = false, right = false, up = false, jumpRequest = false;
      function handleKeydown(e) {
        if (e.repeat) return;
        if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') left = true;
        if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') right = true;
        if(e.key==='ArrowUp' || e.key==='w' || e.key==='W') {
          up = true; jumpRequest = true;
        }
        if(e.key===' ' ) { up = true; jumpRequest = true; }
        if(e.key==='f' || e.key==='F') {
          if (!document.fullscreenElement) {
            if(canvas.requestFullscreen) canvas.requestFullscreen();
            else if(canvas.webkitRequestFullscreen) canvas.webkitRequestFullscreen();
            else if(canvas.mozRequestFullScreen) canvas.mozRequestFullScreen();
            else if(canvas.msRequestFullscreen) canvas.msRequestFullscreen();
            setTimeout(()=>canvas.focus(), 100);
          } else {
            if(document.exitFullscreen) document.exitFullscreen();
            else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if(document.mozCancelFullScreen) document.mozCancelFullScreen();
            else if(document.msExitFullscreen) document.msExitFullscreen();
            setTimeout(()=>canvas.focus(), 100);
          }
        }
        if(e.key==='i' || e.key==='I') {
          inventoryOpen = !inventoryOpen;
          if(inventoryOpen) showInventory();
          else hideInventory();
        }
        if(/[1-9]/.test(e.key)) {
          let idx = parseInt(e.key)-1;
          if(idx >= 0 && idx < HOTBAR_BLOCKS.length) {
            hotbarSelected = idx;
            updateHotbar();
          }
        }
        // Escape: go to menu
        if(e.key === 'Escape') {
          showMenu();
        }
      }
      function handleKeyup(e) {
        if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') left = false;
        if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') right = false;
        if(e.key==='ArrowUp' || e.key==='w' || e.key==='W' || e.key===' ') up = false;
      }
      window.onkeydown = handleKeydown;
      window.onkeyup = handleKeyup;

      function isSolid(x, y) {
        let t = getBlock(x, y);
        return t && t !== 'air';
      }
      function collideAABB(px, py, vx, vy, w, h) {
        let nx = px, ny = py;
        let onGround = false;
        nx += vx;
        let minY = Math.floor(ny + 1e-8), maxY = Math.floor(ny + h - 1e-8);
        if(vx > 0) {
          let rx = nx + w/2 - 1e-8;
          let xBlock = Math.floor(rx);
          for(let y = minY; y <= maxY; y++) {
            if(isSolid(xBlock, y)) {
              nx = xBlock - w/2;
              break;
            }
          }
        } else if(vx < 0) {
          let lx = nx - w/2 + 1e-8;
          let xBlock = Math.floor(lx);
          for(let y = minY; y <= maxY; y++) {
            if(isSolid(xBlock, y)) {
              nx = xBlock + 1 + w/2 - 1e-8;
              break;
            }
          }
        }
        ny += vy;
        let minX = Math.floor(nx - w/2 + 1e-8), maxX = Math.floor(nx + w/2 - 1e-8);
        if(vy > 0) {
          let by = ny + h - 1e-8;
          let yBlock = Math.floor(by);
          for(let x = minX; x <= maxX; x++) {
            if(isSolid(x, yBlock)) {
              ny = yBlock - h;
              onGround = true;
              break;
            }
          }
        } else if(vy < 0) {
          let ty = ny + 1e-8;
          let yBlock = Math.floor(ty);
          for(let x = minX; x <= maxX; x++) {
            if(isSolid(x, yBlock)) {
              ny = yBlock + 1;
              break;
            }
          }
        }
        return {x: nx, y: ny, onGround};
      }
      let jumpActive = false; let jumpTimer = 0; const JUMP_DURATION = 0.34;
      function update() {
        if (stopGameLoop) return;
        ensureWorldGenerated(camera.x, camera.y);

        let targetVx = 0;
        if(left) targetVx -= MOVE_SPEED;
        if(right) targetVx += MOVE_SPEED;
        player.vx += (targetVx - player.vx) * 0.25;

        if(jumpRequest && player.onGround && !jumpActive) {
          jumpActive = true;
          jumpTimer = 0;
        }
        jumpRequest = false;

        let vy = player.vy;
        if(jumpActive) {
          jumpTimer += TICK;
          let t = jumpTimer/JUMP_DURATION;
          if(t < 1) { vy = -JUMP_VEL*(1-t); }
          else { jumpActive = false; }
        } else { vy += GRAVITY; }

        let move = collideAABB(player.x, player.y, player.vx*TICK, vy*TICK, player.w, player.h);
        player.x = move.x; player.y = move.y; player.onGround = move.onGround;
        if(player.onGround) { player.vy = 0; jumpActive = false; }
        else { player.vy = vy; }
        player.y = Math.max(-CAMERA_HEIGHT, player.y);

        let camTargetX = player.x, camTargetY = player.y;
        camera.x += (camTargetX - camera.x) * 0.12;
        camera.y += (camTargetY - camera.y) * 0.12;

        if(!inventoryOpen && mouseDown && player.miningCooldown <= 0) {
          attemptMineOrPlace();
          player.miningCooldown = 0.12;
        }
        if(player.miningCooldown > 0) player.miningCooldown -= TICK;

        periodicMouseTileRefresh();
      }

      function draw() {
        if (stopGameLoop) return;
        let camX = camera.x - CAMERA_WIDTH/2;
        let camY = camera.y - CAMERA_HEIGHT/2;
        ctx.clearRect(0,0,canvas.width,canvas.height);

        let left = Math.floor(camX), top = Math.floor(camY);
        for(let x=left; x<=left+CAMERA_WIDTH; x++) {
          for(let y=top; y<=top+CAMERA_HEIGHT; y++) {
            let t = getBlock(x, y);
            if(t && t !== "air") {
              let px = (x - camX) * BLOCK_SIZE;
              let py = (y - camY) * BLOCK_SIZE;
              let size = BLOCK_SIZE * BLOCK_SCALE;
              let adjust = (size - BLOCK_SIZE) / 2;
              if (
                BLOCK_IMAGES[t] &&
                imageCache[t] &&
                imageCache[t].loaded &&
                !imageCache[t].error
              ) {
                ctx.drawImage(imageCache[t].img, px - adjust, py - adjust, size, size);
              } else {
                ctx.fillStyle = COLORS[t] || "#ff00ff";
                ctx.fillRect(px - adjust, py - adjust, size, size);
              }
            }
          }
        }

        // Draw mining/highlight box snapped perfectly to grid, always follows mouse
        if(mouseTileRefresh) {
          let inReach = isInReach(mouseTileRefresh.x, mouseTileRefresh.y);
          let px = (mouseTileRefresh.x - camX) * BLOCK_SIZE + 1;
          let py = (mouseTileRefresh.y - camY) * BLOCK_SIZE + 1;
          ctx.strokeStyle = inReach ? COLORS.select : "#f44";
          ctx.lineWidth = 2;
          ctx.strokeRect(px, py, BLOCK_SIZE-2, BLOCK_SIZE-2);
        }

        // Draw player
        let sx = (player.x - camX - player.w/2) * BLOCK_SIZE;
        let sy = (player.y - camY) * BLOCK_SIZE;
        ctx.fillStyle = playerInfo && playerInfo.color ? playerInfo.color : COLORS.player;
        ctx.fillRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, player.w*BLOCK_SIZE, player.h*BLOCK_SIZE);
      }

      function gameLoop() {
        if (stopGameLoop) return;
        update();
        draw();
        gameLoopId = requestAnimationFrame(gameLoop);
      }
      gameLoop();
    }
  </script>
</body>
</html>
